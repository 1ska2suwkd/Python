<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Level up! ruru!</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
</head>
<body>
  <script>
    class StartScene extends Phaser.Scene {
      constructor() {
        super('StartScene');
      }

      preload() {
        this.load.image('background', 'background.png'); // ì„ íƒì‚¬í•­
      }

      create() {
        this.add.image(400, 300, 'background').setScale(1.9);

        this.add.text(400, 180, 'Level Up! Ruru!', {
          fontSize: '40px',
          fill: '#ffffff',
          fontFamily: 'Arial'
        }).setOrigin(0.5);

        const startButton = this.add.text(400, 300, 'ê²Œì„ ì‹œì‘', {
          fontSize: '30px',
          fill: '#00ff00'
        }).setOrigin(0.5).setInteractive();

        const codexButton = this.add.text(400, 360, 'ë„ê°', {
          fontSize: '30px',
          fill: '#00ffff'
        }).setOrigin(0.5).setInteractive();

        startButton.on('pointerdown', () => {
          this.scene.start('MainGameScene');
        });

        codexButton.on('pointerdown', () => {
          this.scene.start('CodexScene');
        });
      }
    }    
    

    class MainGameScene extends Phaser.Scene {
      constructor() {
        super('MainGameScene');
        this.player = null;
        this.cursors = null;
        this.xpOrbs = null;
        this.xp = 0;
        this.level = 1;
        this.xpBar = null;
        this.levelText = null;
        this.inventory = [];
        this.inventoryVisible = false;
      }

      preload() {
        this.load.image('player', 'player.png');
        this.load.image('background', 'background.png');
        this.load.image('inventory', 'inventory.png');
        this.load.spritesheet('xpOrbs', 'xpOrbSheet.png', {
          frameWidth: 275,
          frameHeight: 275
        });
        this.load.spritesheet('chest', 'chestSheet.png', {
          frameWidth: 48,
          frameHeight: 40
        });
      }

      getMaxXp(level) {
        return 100 + (level - 1) * 20;
      }

      updateXpBar() {
        const barWidth = 200;
        const barHeight = 10;
        const x = 300;
        const y = 570;
        const fillRatio = this.xp / this.getMaxXp(this.level);

        this.xpBar.clear();
        this.xpBar.fillStyle(0x222222, 1);
        this.xpBar.fillRect(x, y, barWidth, barHeight);
        this.xpBar.fillStyle(0x00ff00, 1);
        this.xpBar.fillRect(x, y, barWidth * fillRatio, barHeight);
      }

      collectXpOrb(player, orb) {
        orb.destroy();
        this.xp += orb.xpValue;

        while (this.xp >= this.getMaxXp(this.level)) {
          this.xp -= this.getMaxXp(this.level);
          this.level++;

          const item = this.getRandomItem();
          this.showLevelUpChest(item); // âœ… ë ˆë²¨ì—… ì‹œ ìƒì ì• ë‹ˆë©”ì´ì…˜
        }

        this.levelText.setText(this.level);
        this.updateXpBar();
      }

      create() {
        this.add.image(400, 300, 'background').setScale(1.9).setDepth(-1);

        this.xpBar = this.add.graphics().setDepth(2);
        this.updateXpBar();

        this.levelText = this.add.text(395, 545, `${this.level}`, {
          fontSize: '20px',
          fill: '#00ff00',
          fontFamily: 'Minecraft',
        }).setDepth(2);

        this.player = this.physics.add.sprite(400, 300, 'player');
        this.player.setScale(0.1);
        this.player.setCollideWorldBounds(false);

        this.cursors = this.input.keyboard.createCursorKeys();

        this.input.keyboard.on('keydown-E', () => {
          if (this.inventoryVisible) {
            this.inventoryImage.setVisible(false);
            this.inventoryVisible = false;
          } else {
            this.inventoryImage.setVisible(true);
            this.inventoryVisible = true;
          }
        });

        this.inventoryImage = this.add.image(400, 300, 'inventory').setDepth(1);
        this.inventoryImage.setOrigin(0.5).setScale(1.3).setVisible(false);
        this.inventoryVisible = false;

        this.xpOrbs = this.physics.add.group();
        this.physics.add.overlap(this.player, this.xpOrbs, this.collectXpOrb, null, this);

        this.anims.create({
          key: 'orbSpin',
          frames: this.anims.generateFrameNumbers('xpOrbs', { start: 0, end: 11 }),
          frameRate: 10,
          repeat: -1
        });

        this.createBoxAnimations();

        this.time.addEvent({
          delay: 1000,
          callback: this.spawnXp0rbs,
          callbackScope: this,
          loop: true
        });
      }

      createBoxAnimations() {
        // D ë“±ê¸‰ (í•˜ìœ„ ë“±ê¸‰)
        this.anims.create({
          key: 'boxD',
          frames: this.anims.generateFrameNumbers('chest', { start: 168, end: 188 }), // D ë“±ê¸‰ ìƒì
          frameRate: 10,
          repeat: -1
        });

        // C ë“±ê¸‰
        this.anims.create({
          key: 'boxC',
          frames: this.anims.generateFrameNumbers('chest', { start: 21, end: 41 }), // C ë“±ê¸‰ ìƒì
          frameRate: 10,
          repeat: -1
        });

        // B ë“±ê¸‰
        this.anims.create({
          key: 'boxB',
          frames: this.anims.generateFrameNumbers('chest', { start: 126, end: 146 }), // B ë“±ê¸‰ ìƒì
          frameRate: 10,
          repeat: -1
        });

        // A ë“±ê¸‰
        this.anims.create({
          key: 'boxA',
          frames: this.anims.generateFrameNumbers('chest', { start: 0, end: 20 }), // A ë“±ê¸‰ ìƒì
          frameRate: 10,
          repeat: -1
        });

        // S ë“±ê¸‰ (ìµœê³  ë“±ê¸‰)
        this.anims.create({
          key: 'boxS',
          frames: this.anims.generateFrameNumbers('chest', { start: 63, end: 83 }), // S ë“±ê¸‰ ìƒì
          frameRate: 10,
          repeat: -1
        });
      }

      // ëœë¤ìœ¼ë¡œ ìƒì ë“±ê¸‰ì„ ì„ íƒí•˜ëŠ” í•¨ìˆ˜
      getRandomBoxAnimation() {
        const rand = Phaser.Math.Between(1, 100); // 1ë¶€í„° 100ê¹Œì§€ ëœë¤ ìˆ«ì
        if (rand <= 10) return 'boxS'; // S ë“±ê¸‰ ìƒì (10% í™•ë¥ )
        if (rand <= 30) return 'boxA'; // A ë“±ê¸‰ ìƒì (20% í™•ë¥ )
        if (rand <= 55) return 'boxB'; // B ë“±ê¸‰ ìƒì (25% í™•ë¥ )
        if (rand <= 80) return 'boxC'; // C ë“±ê¸‰ ìƒì (25% í™•ë¥ )
        return 'boxD'; // D ë“±ê¸‰ ìƒì (20% í™•ë¥ )
      }

      spawnXp0rbs() {
        const x = Phaser.Math.Between(20, this.sys.game.config.width - 20);
        const y = Phaser.Math.Between(20, this.sys.game.config.height - 20);
        const scale = Phaser.Math.FloatBetween(0.05, 0.2);
        const orb = this.xpOrbs.create(x, y, 'xpOrbs');

        orb.setScale(scale);
        orb.play('orbSpin');
        orb.xpValue = Math.round(scale * 200);

        this.time.delayedCall(5000, () => {
          if (orb && orb.active) orb.destroy();
        });
      }

      update() {
        const speed = 400;
        let vx = 0;
        let vy = 0;

        if (this.cursors.left.isDown) vx = -speed;
        else if (this.cursors.right.isDown) vx = speed;

        if (this.cursors.up.isDown) vy = -speed;
        else if (this.cursors.down.isDown) vy = speed;

        this.player.setVelocity(vx, vy);

        const width = this.sys.game.config.width;
        const height = this.sys.game.config.height;

        if (this.player.x < 0) this.player.x = width;
        else if (this.player.x > width) this.player.x = 0;

        if (this.player.y < 0) this.player.y = height;
        else if (this.player.y > height) this.player.y = 0;

        this.xpOrbs.getChildren().forEach((orb) => {
          const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, orb.x, orb.y);
          const attractDistance = 150;
          const maxAttractDistance = 175;

          if (distance < attractDistance) {
            const angle = Phaser.Math.Angle.Between(orb.x, orb.y, this.player.x, this.player.y);
            const speedMultiplier = 0.4;
            orb.setVelocity(Math.cos(angle) * speed * speedMultiplier, Math.sin(angle) * speed * speedMultiplier);
          } else if (distance > maxAttractDistance) {
            orb.setVelocity(0, 0);
          }
        });
      }

      getRandomItem() {
        const itemPool = [
          { name: 'ë„¤ë”ë¼ì´íŠ¸ ê³¡ê´­ì´', probability: 1 },
          { name: 'ë‹¤ì´ì•„ ê³¡ê´­ì´', probability: 20 },
          { name: 'ëŒ ê³¡ê´­ì´', probability: 79 }
        ];
        const rand = Phaser.Math.Between(1, 100);
        let cumulative = 0;

        for (let item of itemPool) {
          cumulative += item.probability;
          if (rand <= cumulative) return item.name;
        }
      }

      showLevelUpChest(itemName) {
        const chest = this.add.sprite(400, 300, 'chest').setScale(6).setDepth(5);
        const animationKey = this.getRandomBoxAnimation();
        chest.play(animationKey);

        const itemText = this.add.text(400, 380, `íšë“! ${itemName}`, {
          fontSize: '24px',
          fill: '#ffff00',
          fontFamily: 'Arial',
          backgroundColor: '#000000'
        }).setOrigin(0.5).setDepth(6);

        this.time.delayedCall(2000, () => {
          chest.destroy();
          itemText.destroy();
        });
      }
    }

      
    class CodexScene extends Phaser.Scene {
      constructor() {
        super('CodexScene');
      }

      create() {
        this.add.text(400, 50, 'ğŸ“– ë„ê°', {
          fontSize: '32px',
          fill: '#ffffff'
        }).setOrigin(0.5);

        // ì˜ˆì‹œ: ì•„ì§ ì•„ì´í…œì´ ì—†ìŒ
        this.add.text(400, 150, 'ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.', {
          fontSize: '20px',
          fill: '#888888'
        }).setOrigin(0.5);

        const backButton = this.add.text(400, 500, 'â† ëŒì•„ê°€ê¸°', {
          fontSize: '24px',
          fill: '#ff4444'
        }).setOrigin(0.5).setInteractive();

        backButton.on('pointerdown', () => {
          this.scene.start('StartScene');
        });
      }
    }

    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      backgroundColor: '#000000',
      physics: {
        default: 'arcade',
        arcade: {
          debug: false
        }
      }, 
      scene: [StartScene, MainGameScene, CodexScene],
      pixelArt: true
    };

    const game = new Phaser.Game(config);
  </script>
</body>
</html>
