<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Level up! cat!</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <style>
    body { margin: 0; background-color: black; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <script type="module">
    // ------------------- ë°ì´í„° ëª¨ë“ˆ ìž„í¬íŠ¸ -------------------
    import masterItemList from './items.js';
    import { playerData, saveData, loadData, resetData} from './playerData.js';


    // ------------------- ì‹œìž‘ ì”¬ (StartScene) -------------------
    class StartScene extends Phaser.Scene {
      constructor() {
        super('StartScene');
      }

      preload() {
        this.load.image('startBackground', 'startBackground.jpeg'); 
        this.load.image('title', 'title.png');
        this.load.image('gameStart', 'gameStart.png');
        this.load.image('codex', 'codex.png');
        
        // ì•„ì´í…œ ìŠ¤í”„ë¼ì´íŠ¸ ì‹œíŠ¸ ë¡œë“œ (ë„ê° ë° ê²Œìž„ ì”¬ì—ì„œ ì‚¬ìš©)
        this.load.spritesheet('item', 'itemSheet.png', {
          frameWidth: 16,
          frameHeight: 16
        });
      }

      create() {
        // ê²Œìž„ ì‹œìž‘ ì‹œ í”Œë ˆì´ì–´ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
        loadData();

        this.add.image(400, 300, 'startBackground').setScale(1.9);
        this.add.image(400, 180, 'title').setOrigin(0.5).setScale(0.5);
        const startButton = this.add.image(400, 320, 'gameStart')
            .setOrigin(0.5).setScale(0.3).setInteractive();
        const codexButton = this.add.image(400, 400, 'codex')
            .setOrigin(0.5).setScale(0.2).setInteractive();

        startButton.on('pointerdown', () => this.scene.start('MainGameScene'));
        codexButton.on('pointerdown', () => this.scene.start('CodexScene'));
      
        const resetButton = this.add.text(720, 560, 'ë°ì´í„° ì´ˆê¸°í™”', {
              fontSize: '18px',
              fill: '#FF0000', // ë¹¨ê°„ìƒ‰
              fontFamily: 'Arial', // í°íŠ¸ ì„¤ì • (ì›í•˜ëŠ” í°íŠ¸ë¡œ ë³€ê²½ ê°€ëŠ¥)
              backgroundColor: '#333333', // ë°°ê²½ìƒ‰ì„ ì–´ë‘¡ê²Œ í•˜ì—¬ ê¸€ì”¨ê°€ ìž˜ ë³´ì´ë„ë¡
              padding: { x: 10, y: 5 }
          })
          .setOrigin(0.5) // ì¤‘ì•™ ì •ë ¬
          .setInteractive() // í´ë¦­ ê°€ëŠ¥í•˜ê²Œ ì„¤ì •
          .setDepth(1); // ë‹¤ë¥¸ ìš”ì†Œ ìœ„ì— í‘œì‹œë˜ë„ë¡ Z-index ì„¤ì • (ì„ íƒ ì‚¬í•­)

          // ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
          resetButton.on('pointerdown', () => {
              // resetData í•¨ìˆ˜ í˜¸ì¶œí•˜ì—¬ ë°ì´í„° ì´ˆê¸°í™”
              resetData();
              // ì‚¬ìš©ìžì—ê²Œ ì•Œë¦¼ (Phaser Textë¡œ ê°„ë‹¨í•œ ë©”ì‹œì§€ í‘œì‹œ)
              const alertText = this.add.text(400, 300, 'ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!', {
                  fontSize: '30px',
                  fill: '#FFFFFF',
                  backgroundColor: '#000000',
                  padding: { x: 20, y: 10 }
              }).setOrigin(0.5).setDepth(10); // ê°€ìž¥ ìœ„ì— í‘œì‹œ

              // í…ìŠ¤íŠ¸ê°€ ìž ì‹œ ë³´ì˜€ë‹¤ê°€ ì‚¬ë¼ì§€ë„ë¡ íŠ¸ìœˆ ì¶”ê°€
              this.tweens.add({
                  targets: alertText,
                  alpha: 0,
                  ease: 'Power1',
                  duration: 2000,
                  delay: 1000, // 1ì´ˆ í›„ ì‚¬ë¼ì§€ê¸° ì‹œìž‘
                  onComplete: () => {
                      alertText.destroy(); // íŠ¸ìœˆ ì™„ë£Œ í›„ í…ìŠ¤íŠ¸ ì œê±°
                      // ë°ì´í„° ì´ˆê¸°í™” í›„ StartSceneì„ ë‹¤ì‹œ ì‹œìž‘í•˜ì—¬ UI ê°±ì‹  (ì„ íƒ ì‚¬í•­)
                      // this.scene.restart();
                  }
              });
          });

          // ë§ˆìš°ìŠ¤ ì˜¤ë²„ ì‹œ ìŠ¤íƒ€ì¼ ë³€ê²½ (ì„ íƒ ì‚¬í•­)
          resetButton.on('pointerover', () => resetButton.setStyle({ fill: '#FFFF00' })); // ë…¸ëž€ìƒ‰ìœ¼ë¡œ ë³€ê²½
          resetButton.on('pointerout', () => resetButton.setStyle({ fill: '#FF0000' })); // ë‹¤ì‹œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ
        }
      }
    

    // ------------------- ë©”ì¸ ê²Œìž„ ì”¬ (MainGameScene) -------------------
  class MainGameScene extends Phaser.Scene {
    constructor() {
      super('MainGameScene');
      this.player = null;
      this.cursors = null;
      this.xpOrbs = null;
      this.xp = 0;
      this.level = 1;
      this.xpBar = null;
      this.levelText = null;
      this.boxTypes = {};
      this.itemAnimationQueue = [];
      this.isAnimationPlaying = false; // âœ¨ ìƒˆë¡œìš´ í”Œëž˜ê·¸ ì¶”ê°€ âœ¨: í˜„ìž¬ ë ˆë²¨ì—… ì• ë‹ˆë©”ì´ì…˜ì´ ìž¬ìƒ ì¤‘ì¸ì§€
    }

    preload() {
      this.load.spritesheet('playerSpriteSheet', 'player.png', {
        frameWidth: 32,
        frameHeight: 32,
      });
      this.load.image('background', 'background.png');
      this.load.spritesheet('xpOrbs', 'xpOrbSheet.png', {
        frameWidth: 275,
        frameHeight: 275
      });
      this.load.spritesheet('chest', 'chestSheet.png', {
        frameWidth: 48,
        frameHeight: 40
      });
      // StartSceneì—ë„ ìžˆì§€ë§Œ, ëª…í™•ì„±ì„ ìœ„í•´ MainGameSceneì—ë„ ë¡œë“œ
      this.load.spritesheet('item', 'itemSheet.png', {
        frameWidth: 16, // ì‹¤ì œ itemSheet.pngì˜ í”„ë ˆìž„ í­ê³¼ ë†’ì´ì— ë§žê²Œ ìˆ˜ì •
        frameHeight: 16
      });
    }

    create() {
      this.isAnimationPlaying = false;
      this.itemAnimationQueue = [];
      this.boxTypes = {
        'boxS': [1], 'boxA': [2], 'boxB': [3], 'boxC': [4, 5, 6], 'boxD': [7]
      };

      this.add.image(400, 300, 'background').setScale(1.9).setDepth(-1);
      this.xpBar = this.add.graphics().setDepth(2);
      this.updateXpBar();
      this.levelText = this.add.text(395, 545, `${this.level}`, {
        fontSize: '20px', fill: '#00ff00', fontFamily: 'Minecraft',
      }).setDepth(2);

      this.player = this.physics.add.sprite(400, 300, 'playerSpriteSheet', 0);
      this.player.setScale(4);
      this.player.setCollideWorldBounds(false);

      this.anims.create({
        key: 'player_walk_stop',
        frames: this.anims.generateFrameNumbers('playerSpriteSheet', { start: 0, end: 3 }),
        frameRate: 4,
        repeat: -1
      });

      this.anims.create({
        key: 'player_walk_down',
        frames: this.anims.generateFrameNumbers('playerSpriteSheet', { start: 20, end: 27 }),
        frameRate: 10,
        repeat: -1
      });

      this.anims.create({
        key: 'player_walk_left',
        frames: this.anims.generateFrameNumbers('playerSpriteSheet', { start: 28, end: 35 }),
        frameRate: 10,
        repeat: -1
      });

      this.anims.create({
        key: 'player_walk_right',
        frames: this.anims.generateFrameNumbers('playerSpriteSheet', { start: 36, end: 43 }),
        frameRate: 10,
        repeat: -1
      });

      this.anims.create({
        key: 'player_walk_up',
        frames: this.anims.generateFrameNumbers('playerSpriteSheet', { start: 44, end: 51 }),
        frameRate: 10,
        repeat: -1
      });
      this.cursors = this.input.keyboard.createCursorKeys();
      this.xpOrbs = this.physics.add.group();
      this.physics.add.overlap(this.player, this.xpOrbs, this.collectXpOrb, null, this);

      this.anims.create({ key: 'orbSpin', frames: this.anims.generateFrameNumbers('xpOrbs', { start: 0, end: 11 }), frameRate: 10, repeat: -1 });
      this.createBoxAnimations();
      this.time.addEvent({ delay: 1000, callback: this.spawnXpOrbs, callbackScope: this, loop: true });
      this.input.keyboard.on('keydown-ESC', this.handleEscapeKey, this);
    }

    handleEscapeKey() {
      this.scene.start('StartScene');
    }

    createBoxAnimations() {
      Object.keys(this.boxTypes).forEach((boxType) => {
        const frames = this.getFramesForBox(boxType);
        this.anims.create({ key: boxType, frames: this.anims.generateFrameNumbers('chest', { start: frames.start, end: frames.end }), frameRate: 10, repeat: 0 });
      });
    }

    getFramesForBox(boxType) {
      const framesMap = { 'boxS': { start: 63, end: 83 }, 'boxA': { start: 0, end: 20 }, 'boxB': { start: 126, end: 146 }, 'boxC': { start: 21, end: 41 }, 'boxD': { start: 168, end: 188 } };
      return framesMap[boxType] || { start: 0, end: 0 };
    }

    collectXpOrb(player, orb) {
      orb.destroy();
      this.xp += orb.xpValue;

      let leveledUpThisCall = false;

      while (this.xp >= this.getMaxXp(this.level)) {
        this.xp -= this.getMaxXp(this.level);
        this.level++;
        leveledUpThisCall = true;
      }

      if (leveledUpThisCall) {
        this.itemAnimationQueue.push({ type: 'levelUpAnimation' });

        // âœ¨ ìˆ˜ì •ëœ ì¡°ê±´: í˜„ìž¬ ì• ë‹ˆë©”ì´ì…˜ì´ ìž¬ìƒ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ í ì²˜ë¦¬ë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤. âœ¨
        if (!this.isAnimationPlaying) {
          this.processAnimationQueue();
        }
      }

      this.levelText.setText(this.level);
      this.updateXpBar();
    }

    processAnimationQueue() {
      // íê°€ ë¹„ì–´ìžˆìœ¼ë©´ ë” ì´ìƒ ì²˜ë¦¬í•  ì• ë‹ˆë©”ì´ì…˜ì´ ì—†ìœ¼ë¯€ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.
      if (this.itemAnimationQueue.length === 0) {
        this.isAnimationPlaying = false; // âœ¨ íê°€ ë¹„ë©´ ì• ë‹ˆë©”ì´ì…˜ ìž¬ìƒ ìƒíƒœë¥¼ falseë¡œ ì„¤ì • âœ¨
        return;
      }

      // âœ¨ ì• ë‹ˆë©”ì´ì…˜ ìž¬ìƒ ì‹œìž‘ì„ ì•Œë¦½ë‹ˆë‹¤. âœ¨
      this.isAnimationPlaying = true;

      // íì—ì„œ ë‹¤ìŒ ì• ë‹ˆë©”ì´ì…˜ ìš”ì²­ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
      const animationRequest = this.itemAnimationQueue.shift();

      if (animationRequest.type === 'levelUpAnimation') {
        const chest = this.add.sprite(400, 300, 'chest').setScale(6).setDepth(5);
        const animationKey = this.getRandomBoxAnimation();

        chest.play(animationKey);
        chest.on(Phaser.Animations.Events.ANIMATION_COMPLETE, (anim) => {
          if (anim.key === animationKey) {
            const itemIds = this.boxTypes[animationKey];
            const randomItemId = Phaser.Math.RND.pick(itemIds);
            const itemData = masterItemList.find(item => item.id === randomItemId);

            if (!itemData) {
              chest.destroy();
              // ì•„ì´í…œì„ ì°¾ì§€ ëª»í–ˆìœ¼ë¯€ë¡œ ë‹¤ìŒ í í•­ëª©ì„ ë°”ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
              this.processAnimationQueue();
              return;
            }

            this.registerItemInCodex(itemData.id);

            const itemSprite = this.add.sprite(chest.x, chest.y, 'item', itemData.frame).setScale(10).setDepth(5);
            const itemNameText = this.add.text(chest.x, chest.y - 60, itemData.name, {
              fontSize: '30px', fill: '#ffffff', fontFamily: '"Press Start 2P"', stroke: '#000000', strokeThickness: 2,
            }).setOrigin(0.5).setDepth(6);

            this.tweens.add({
              targets: itemSprite, y: chest.y - 100, ease: 'Power2', duration: 800,
              onComplete: () => {
                // ì•„ì´í…œ í…ìŠ¤íŠ¸ì™€ ìŠ¤í”„ë¼ì´íŠ¸ê°€ ì™„ì „ížˆ ì‚¬ë¼ì§€ëŠ” ë”œë ˆì´ (3000ms) í›„ì— ë‹¤ìŒ í í•­ëª© ì²˜ë¦¬
                this.time.delayedCall(2500, () => {
                  itemSprite.destroy();
                  itemNameText.destroy();
                  chest.destroy();

                  // âœ¨ í˜„ìž¬ ì• ë‹ˆë©”ì´ì…˜ ì‹œí€€ìŠ¤ê°€ ì™„ì „ížˆ ëë‚¬ìœ¼ë¯€ë¡œ ë‹¤ìŒ í í•­ëª©ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤. âœ¨
                  this.processAnimationQueue();
                });
              }
            });
          }
        });
      }
    }

    registerItemInCodex(itemId) {
      if (!playerData.discoveredItems.has(itemId)) {
        playerData.discoveredItems.add(itemId);
        saveData();
        const alertText = this.add.text(400, 100, 'ìƒˆë¡œìš´ ì•„ì´í…œ ë„ê°ì— ë“±ë¡!', {
          fontSize: '20px', fill: '#FFD700', stroke: '#000', strokeThickness: 2
        }).setOrigin(0.5).setDepth(10);
        this.tweens.add({ targets: alertText, alpha: 0, ease: 'Linear', duration: 2000, onComplete: () => alertText.destroy() });
      }
    }

    getRandomBoxAnimation() {
      const rand = Phaser.Math.Between(1, 100);
      if (rand <= 10) return 'boxS';
      if (rand <= 25) return 'boxA';
      if (rand <= 45) return 'boxB';
      if (rand <= 70) return 'boxC';
      return 'boxD';
    }

    update() {
      const speed = 400;
      let vx = 0, vy = 0;
      let isMoving = false;
      let targetAnim = '';

      if (this.cursors.left.isDown) {
        vx = -speed;
        isMoving = true;
      } else if (this.cursors.right.isDown) {
        vx = speed;
        isMoving = true;
      }

      if (this.cursors.up.isDown) {
        vy = -speed;
        isMoving = true;
      } else if (this.cursors.down.isDown) {
        vy = speed;
        isMoving = true;
      }

      this.player.setVelocity(vx, vy);

      if (isMoving) {
        if (this.cursors.left.isDown) {
          targetAnim = 'player_walk_left';
        } else if (this.cursors.right.isDown) {
          targetAnim = 'player_walk_right';
        } else if (this.cursors.up.isDown) {
          targetAnim = 'player_walk_up';
        } else if (this.cursors.down.isDown) {
          targetAnim = 'player_walk_down';
        }
        if (this.player.anims.currentAnim === null || this.player.anims.currentAnim.key !== targetAnim) {
          this.player.play(targetAnim);
        }
      } else {
        targetAnim = 'player_walk_stop'
        if (this.player.anims.currentAnim === null || this.player.anims.currentAnim.key !== targetAnim) {
          this.player.play(targetAnim);
        }
      }

      const width = this.sys.game.config.width;
      const height = this.sys.game.config.height;

      if (this.player.x < 0) this.player.x = width; else if (this.player.x > width) this.player.x = 0;
      if (this.player.y < 0) this.player.y = height; else if (this.player.y > height) this.player.y = 0;

      this.xpOrbs.getChildren().forEach(orb => {
        const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, orb.x, orb.y);
        if (distance < 175) {
          if (orb.body.velocity.x === 0 && orb.body.velocity.y === 0) {
            this.physics.moveToObject(orb, this.player, speed * 0.4);
          }
        } else {
          orb.setVelocity(0, 0);
        }
      });
    }
    getMaxXp(level) { return 100 + (level - 1) * 20; }
    updateXpBar() {
      const barWidth = 200, barHeight = 10, x = 300, y = 570;
      const fillRatio = this.xp / this.getMaxXp(this.level);
      this.xpBar.clear();
      this.xpBar.fillStyle(0x222222, 1).fillRect(x, y, barWidth, barHeight);
      this.xpBar.fillStyle(0x00ff00, 1).fillRect(x, y, barWidth * fillRatio, barHeight);
    }
    spawnXpOrbs() {
      const x = Phaser.Math.Between(20, 780), y = Phaser.Math.Between(20, 580);
      const scale = Phaser.Math.FloatBetween(0.05, 0.2);
      const orb = this.xpOrbs.create(x, y, 'xpOrbs').setScale(scale).play('orbSpin');
      orb.xpValue = Math.round(scale * 200);
      this.time.delayedCall(5000, () => orb.active && orb.destroy());
    }
  }
    
    // ------------------- ë„ê° ì”¬ (CodexScene) -------------------
    class CodexScene extends Phaser.Scene {
      constructor() {
        super('CodexScene');
        this.descriptionText = null;
      }

      create() {
        this.add.image(400, 300, 'startBackground').setScale(1.9).setDepth(-1);
        this.add.text(400, 50, 'ðŸ“– ë„ê°', { fontSize: '32px', fill: '#ffffff' }).setOrigin(0.5);

        const startX = 120, startY = 140, itemSize = 100, columns = 6;

        masterItemList.forEach((item, index) => {
          const x = startX + (index % columns) * itemSize;
          const y = startY + Math.floor(index / columns) * itemSize;
          const itemIcon = this.add.sprite(x, y, 'item', item.frame).setScale(4);

          if (playerData.discoveredItems.has(item.id)) {
            itemIcon.setInteractive().on('pointerdown', () => this.showItemDescription(item));
          } else {
            itemIcon.setTint(0x000000); 
          }
        });
        
        this.descriptionText = this.add.text(400, 480, 'ì•„ì´í…œì„ í´ë¦­í•˜ì—¬ ì„¤ëª…ì„ í™•ì¸í•˜ì„¸ìš”.', {
          fontSize: '16px', fill: '#ffffcc', fontFamily: 'sans-serif',
          wordWrap: { width: 600 }, align: 'center'
        }).setOrigin(0.5);

        const backButton = this.add.text(400, 550, 'â† ëŒì•„ê°€ê¸°', {
          fontSize: '24px', fill: '#ff4444'
        }).setOrigin(0.5).setInteractive();

        backButton.on('pointerdown', () => this.scene.start('StartScene'));
        this.input.keyboard.on('keydown-ESC', this.handleEscapeKey, this);
      }

      handleEscapeKey() {
        this.scene.start('StartScene');
      }
      
      showItemDescription(item) {
        if (this.descriptionText) {
          this.descriptionText.setText(`[${item.grade}ë“±ê¸‰] ${item.name}\n\n${item.description}`);
        }
      }
    }

    // ------------------- ê²Œìž„ ì„¤ì • (Config) -------------------
    const config = {
      type: Phaser.AUTO,
      width: 800,
      height: 600,
      backgroundColor: '#000000',
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      },
      scene: [StartScene, MainGameScene, CodexScene],
      pixelArt: true
    };

    const game = new Phaser.Game(config);
  </script>
</body>
</html>
